{
  "description": "BatchTransfer is the Schema for the batchtransfers API",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": [
        "string",
        "null"
      ],
      "enum": [
        "motion.fybrik.io/v1alpha1"
      ]
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": [
        "string",
        "null"
      ],
      "enum": [
        "BatchTransfer"
      ]
    },
    "metadata": {
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      "$ref": "_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta_v2"
    },
    "spec": {
      "description": "BatchTransferSpec defines the state of a BatchTransfer. The state includes source/destination specification, a schedule and the means by which data movement is to be conducted. The means is given as a kubernetes job description. In addition, the state also contains a sketch of a transformation instruction. In future releases, the transformation description should be specified in a separate CRD.",
      "type": [
        "object",
        "null"
      ],
      "required": [
        "destination",
        "source"
      ],
      "properties": {
        "destination": {
          "description": "Destination data store for this batch job",
          "type": "object",
          "properties": {
            "cloudant": {
              "description": "IBM Cloudant. Needs cloudant legacy credentials.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "database",
                "host"
              ],
              "properties": {
                "database": {
                  "description": "Database to be read from/written to",
                  "type": "string"
                },
                "host": {
                  "description": "Host of cloudant instance",
                  "type": "string"
                },
                "password": {
                  "description": "Cloudant password. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "username": {
                  "description": "Cloudant user. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "database": {
              "description": "Database data store. For the moment only Db2 is supported.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "db2URL",
                "table"
              ],
              "properties": {
                "db2URL": {
                  "description": "URL to Db2 instance in JDBC format Supported SSL certificates are currently certificates signed with IBM Intermediate CA or cloud signed certificates.",
                  "type": "string"
                },
                "password": {
                  "description": "Database password. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "table": {
                  "description": "Table to be read",
                  "type": "string"
                },
                "user": {
                  "description": "Database user. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "description": {
              "description": "Description of the transfer in human readable form that is displayed in the kubectl get If not provided this will be filled in depending on the datastore that is specified.",
              "type": [
                "string",
                "null"
              ]
            },
            "kafka": {
              "description": "Kafka data store. The supposed format within the given Kafka topic is a Confluent compatible format stored as Avro. A schema registry needs to be specified as well.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "kafkaBrokers",
                "kafkaTopic"
              ],
              "properties": {
                "createSnapshot": {
                  "description": "If a snapshot should be created of the topic. Records in Kafka are stored as key-value pairs. Updates/Deletes for the same key are appended to the Kafka topic and the last value for a given key is the valid key in a Snapshot. When this property is true only the last value will be written. If the property is false all values will be written out. As a CDC example: If the property is true a valid snapshot of the log stream will be created. If the property is false the CDC stream will be dumped as is like a change log.",
                  "type": [
                    "boolean",
                    "null"
                  ]
                },
                "dataFormat": {
                  "description": "Data format of the objects in S3. e.g. parquet or csv. Please refer to struct for allowed values.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "kafkaBrokers": {
                  "description": "Kafka broker URLs as a comma separated list.",
                  "type": "string"
                },
                "kafkaTopic": {
                  "description": "Kafka topic",
                  "type": "string"
                },
                "keyDeserializer": {
                  "description": "Deserializer to be used for the keys of the topic",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "password": {
                  "description": "Kafka user password Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "saslMechanism": {
                  "description": "SASL Mechanism to be used (e.g. PLAIN or SCRAM-SHA-512) Default SCRAM-SHA-512 will be assumed if not specified",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "schemaRegistryURL": {
                  "description": "URL to the schema registry. The registry has to be Confluent schema registry compatible.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "securityProtocol": {
                  "description": "Kafka security protocol one of (PLAINTEXT, SASL_PLAINTEXT, SASL_SSL, SSL) Default SASL_SSL will be assumed if not specified",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststore": {
                  "description": "A truststore or certificate encoded as base64. The format can be JKS or PKCS12. A truststore can be specified like this or in a predefined Kubernetes secret",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststoreLocation": {
                  "description": "SSL truststore location.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststorePassword": {
                  "description": "SSL truststore password.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststoreSecret": {
                  "description": "Kubernetes secret that contains the SSL truststore. The format can be JKS or PKCS12. A truststore can be specified like this or as",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "user": {
                  "description": "Kafka user name. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "valueDeserializer": {
                  "description": "Deserializer to be used for the values of the topic",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "s3": {
              "description": "An object store data store that is compatible with S3. This can be a COS bucket.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "bucket",
                "endpoint",
                "objectKey"
              ],
              "properties": {
                "accessKey": {
                  "description": "Access key of the HMAC credentials that can access the given bucket. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "bucket": {
                  "description": "Bucket of S3 service",
                  "type": "string"
                },
                "dataFormat": {
                  "description": "Data format of the objects in S3. e.g. parquet or csv. Please refer to struct for allowed values.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "endpoint": {
                  "description": "Endpoint of S3 service",
                  "type": "string"
                },
                "objectKey": {
                  "description": "Object key of the object in S3. This is used as a prefix! Thus all objects that have the given objectKey as prefix will be used as input!",
                  "type": "string"
                },
                "partitionBy": {
                  "description": "Partition by partition (for target data stores) Defines the columns to partition the output by for a target data store.",
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "region": {
                  "description": "Region of S3 service",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretKey": {
                  "description": "Secret key of the HMAC credentials that can access the given bucket. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "failedJobHistoryLimit": {
          "description": "Maximal number of failed Kubernetes job objects that should be kept. This property will be defaulted by the webhook if not set.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 20,
          "minimum": 0
        },
        "flowType": {
          "description": "Data flow type that specifies if this is a stream or a batch workflow",
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "Batch",
            "Stream"
          ]
        },
        "image": {
          "description": "Image that should be used for the actual batch job. This is usually a datamover image. This property will be defaulted by the webhook if not set.",
          "type": [
            "string",
            "null"
          ]
        },
        "imagePullPolicy": {
          "description": "Image pull policy that should be used for the actual job. This property will be defaulted by the webhook if not set.",
          "type": [
            "string",
            "null"
          ]
        },
        "maxFailedRetries": {
          "description": "Maximal number of failed retries until the batch job should stop trying. This property will be defaulted by the webhook if not set.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 10,
          "minimum": 0
        },
        "noFinalizer": {
          "description": "If this batch job instance should have a finalizer or not. This property will be defaulted by the webhook if not set.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "readDataType": {
          "description": "Data type of the data that is read from source (log data or change data)",
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "LogData",
            "ChangeData"
          ]
        },
        "schedule": {
          "description": "Cron schedule if this BatchTransfer job should run on a regular schedule. Values are specified like cron job schedules. A good translation to human language can be found here https://crontab.guru/",
          "type": [
            "string",
            "null"
          ]
        },
        "secretProviderRole": {
          "description": "Secret provider role that should be used for the actual job. This property will be defaulted by the webhook if not set.",
          "type": [
            "string",
            "null"
          ]
        },
        "secretProviderURL": {
          "description": "Secret provider url that should be used for the actual job. This property will be defaulted by the webhook if not set.",
          "type": [
            "string",
            "null"
          ]
        },
        "source": {
          "description": "Source data store for this batch job",
          "type": "object",
          "properties": {
            "cloudant": {
              "description": "IBM Cloudant. Needs cloudant legacy credentials.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "database",
                "host"
              ],
              "properties": {
                "database": {
                  "description": "Database to be read from/written to",
                  "type": "string"
                },
                "host": {
                  "description": "Host of cloudant instance",
                  "type": "string"
                },
                "password": {
                  "description": "Cloudant password. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "username": {
                  "description": "Cloudant user. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "database": {
              "description": "Database data store. For the moment only Db2 is supported.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "db2URL",
                "table"
              ],
              "properties": {
                "db2URL": {
                  "description": "URL to Db2 instance in JDBC format Supported SSL certificates are currently certificates signed with IBM Intermediate CA or cloud signed certificates.",
                  "type": "string"
                },
                "password": {
                  "description": "Database password. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "table": {
                  "description": "Table to be read",
                  "type": "string"
                },
                "user": {
                  "description": "Database user. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "description": {
              "description": "Description of the transfer in human readable form that is displayed in the kubectl get If not provided this will be filled in depending on the datastore that is specified.",
              "type": [
                "string",
                "null"
              ]
            },
            "kafka": {
              "description": "Kafka data store. The supposed format within the given Kafka topic is a Confluent compatible format stored as Avro. A schema registry needs to be specified as well.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "kafkaBrokers",
                "kafkaTopic"
              ],
              "properties": {
                "createSnapshot": {
                  "description": "If a snapshot should be created of the topic. Records in Kafka are stored as key-value pairs. Updates/Deletes for the same key are appended to the Kafka topic and the last value for a given key is the valid key in a Snapshot. When this property is true only the last value will be written. If the property is false all values will be written out. As a CDC example: If the property is true a valid snapshot of the log stream will be created. If the property is false the CDC stream will be dumped as is like a change log.",
                  "type": [
                    "boolean",
                    "null"
                  ]
                },
                "dataFormat": {
                  "description": "Data format of the objects in S3. e.g. parquet or csv. Please refer to struct for allowed values.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "kafkaBrokers": {
                  "description": "Kafka broker URLs as a comma separated list.",
                  "type": "string"
                },
                "kafkaTopic": {
                  "description": "Kafka topic",
                  "type": "string"
                },
                "keyDeserializer": {
                  "description": "Deserializer to be used for the keys of the topic",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "password": {
                  "description": "Kafka user password Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "saslMechanism": {
                  "description": "SASL Mechanism to be used (e.g. PLAIN or SCRAM-SHA-512) Default SCRAM-SHA-512 will be assumed if not specified",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "schemaRegistryURL": {
                  "description": "URL to the schema registry. The registry has to be Confluent schema registry compatible.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "securityProtocol": {
                  "description": "Kafka security protocol one of (PLAINTEXT, SASL_PLAINTEXT, SASL_SSL, SSL) Default SASL_SSL will be assumed if not specified",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststore": {
                  "description": "A truststore or certificate encoded as base64. The format can be JKS or PKCS12. A truststore can be specified like this or in a predefined Kubernetes secret",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststoreLocation": {
                  "description": "SSL truststore location.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststorePassword": {
                  "description": "SSL truststore password.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "sslTruststoreSecret": {
                  "description": "Kubernetes secret that contains the SSL truststore. The format can be JKS or PKCS12. A truststore can be specified like this or as",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "user": {
                  "description": "Kafka user name. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "valueDeserializer": {
                  "description": "Deserializer to be used for the values of the topic",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "s3": {
              "description": "An object store data store that is compatible with S3. This can be a COS bucket.",
              "type": [
                "object",
                "null"
              ],
              "required": [
                "bucket",
                "endpoint",
                "objectKey"
              ],
              "properties": {
                "accessKey": {
                  "description": "Access key of the HMAC credentials that can access the given bucket. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "bucket": {
                  "description": "Bucket of S3 service",
                  "type": "string"
                },
                "dataFormat": {
                  "description": "Data format of the objects in S3. e.g. parquet or csv. Please refer to struct for allowed values.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "endpoint": {
                  "description": "Endpoint of S3 service",
                  "type": "string"
                },
                "objectKey": {
                  "description": "Object key of the object in S3. This is used as a prefix! Thus all objects that have the given objectKey as prefix will be used as input!",
                  "type": "string"
                },
                "partitionBy": {
                  "description": "Partition by partition (for target data stores) Defines the columns to partition the output by for a target data store.",
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "region": {
                  "description": "Region of S3 service",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretImport": {
                  "description": "Define a secret import definition.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "secretKey": {
                  "description": "Secret key of the HMAC credentials that can access the given bucket. Can be retrieved from vault if specified in vault parameter and is thus optional.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "vault": {
                  "description": "Define secrets that are fetched from a Vault instance",
                  "type": [
                    "object",
                    "null"
                  ],
                  "required": [
                    "address",
                    "authPath",
                    "role",
                    "secretPath"
                  ],
                  "properties": {
                    "address": {
                      "description": "Address is Vault address",
                      "type": "string"
                    },
                    "authPath": {
                      "description": "AuthPath is the path to auth method i.e. kubernetes",
                      "type": "string"
                    },
                    "role": {
                      "description": "Role is the Vault role used for retrieving the credentials",
                      "type": "string"
                    },
                    "secretPath": {
                      "description": "SecretPath is the path of the secret holding the Credentials in Vault",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "spark": {
          "description": "Optional Spark configuration for tuning",
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "appName": {
              "description": "Name of the transaction. Mainly used for debugging and lineage tracking.",
              "type": [
                "string",
                "null"
              ]
            },
            "driverCores": {
              "description": "Number of cores that the driver should use",
              "type": [
                "integer",
                "null"
              ]
            },
            "driverMemory": {
              "description": "Memory that the driver should have",
              "type": [
                "integer",
                "null"
              ]
            },
            "executorCores": {
              "description": "Number of cores that each executor should have",
              "type": [
                "integer",
                "null"
              ]
            },
            "executorMemory": {
              "description": "Memory that each executor should have",
              "type": [
                "string",
                "null"
              ]
            },
            "image": {
              "description": "Image to be used for executors",
              "type": [
                "string",
                "null"
              ]
            },
            "imagePullPolicy": {
              "description": "Image pull policy to be used for executor",
              "type": [
                "string",
                "null"
              ]
            },
            "numExecutors": {
              "description": "Number of executors to be started",
              "type": [
                "integer",
                "null"
              ]
            },
            "options": {
              "description": "Additional options for Spark configuration.",
              "additionalProperties": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "x-kubernetes-preserve-unknown-fields": true
            },
            "shufflePartitions": {
              "description": "Number of shuffle partitions for Spark",
              "type": [
                "integer",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "successfulJobHistoryLimit": {
          "description": "Maximal number of successful Kubernetes job objects that should be kept. This property will be defaulted by the webhook if not set.",
          "type": [
            "integer",
            "null"
          ],
          "maximum": 20,
          "minimum": 0
        },
        "suspend": {
          "description": "If this batch job instance is run on a schedule the regular schedule can be suspended with this property. This property will be defaulted by the webhook if not set.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "transformation": {
          "description": "Transformations to be applied to the source data before writing to destination",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "description": "to be refined...",
            "type": [
              "object",
              "null"
            ],
            "properties": {
              "action": {
                "description": "Transformation action that should be performed.",
                "type": [
                  "string",
                  "null"
                ],
                "enum": [
                  "RemoveColumns",
                  "EncryptColumns",
                  "DigestColumns",
                  "RedactColumns",
                  "SampleRows",
                  "FilterRows"
                ]
              },
              "columns": {
                "description": "Columns that are involved in this action. This property is optional as for some actions no columns have to be specified. E.g. filter is a row based transformation.",
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "name": {
                "description": "Name of the transaction. Mainly used for debugging and lineage tracking.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "options": {
                "description": "Additional options for this transformation.",
                "additionalProperties": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "x-kubernetes-preserve-unknown-fields": true
              }
            },
            "additionalProperties": false
          }
        },
        "writeDataType": {
          "description": "Data type of how the data should be written to the target (log data or change data)",
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "LogData",
            "ChangeData"
          ]
        },
        "writeOperation": {
          "description": "Write operation that should be performed when writing (overwrite,append,update) Caution: Some write operations are only available for batch and some only for stream.",
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "Overwrite",
            "Append",
            "Update"
          ]
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "BatchTransferStatus defines the observed state of BatchTransfer This includes a reference to the job that implements the movement as well as the last schedule time. What is missing: Extended status information such as: - number of records moved - technical meta-data",
      "type": [
        "object",
        "null"
      ],
      "properties": {
        "active": {
          "description": "A pointer to the currently running job (or nil)",
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "apiVersion": {
              "description": "API version of the referent.",
              "type": [
                "string",
                "null"
              ]
            },
            "fieldPath": {
              "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
              "type": [
                "string",
                "null"
              ]
            },
            "kind": {
              "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
              "type": [
                "string",
                "null"
              ]
            },
            "name": {
              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
              "type": [
                "string",
                "null"
              ]
            },
            "namespace": {
              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
              "type": [
                "string",
                "null"
              ]
            },
            "resourceVersion": {
              "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
              "type": [
                "string",
                "null"
              ]
            },
            "uid": {
              "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "error": {
          "type": [
            "string",
            "null"
          ]
        },
        "lastCompleted": {
          "description": "ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, \"must refer only to types A and B\" or \"UID not honored\" or \"name must be restricted\".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .",
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "apiVersion": {
              "description": "API version of the referent.",
              "type": [
                "string",
                "null"
              ]
            },
            "fieldPath": {
              "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
              "type": [
                "string",
                "null"
              ]
            },
            "kind": {
              "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
              "type": [
                "string",
                "null"
              ]
            },
            "name": {
              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
              "type": [
                "string",
                "null"
              ]
            },
            "namespace": {
              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
              "type": [
                "string",
                "null"
              ]
            },
            "resourceVersion": {
              "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
              "type": [
                "string",
                "null"
              ]
            },
            "uid": {
              "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "lastFailed": {
          "description": "ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, \"must refer only to types A and B\" or \"UID not honored\" or \"name must be restricted\".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .",
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "apiVersion": {
              "description": "API version of the referent.",
              "type": [
                "string",
                "null"
              ]
            },
            "fieldPath": {
              "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.",
              "type": [
                "string",
                "null"
              ]
            },
            "kind": {
              "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
              "type": [
                "string",
                "null"
              ]
            },
            "name": {
              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
              "type": [
                "string",
                "null"
              ]
            },
            "namespace": {
              "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
              "type": [
                "string",
                "null"
              ]
            },
            "resourceVersion": {
              "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
              "type": [
                "string",
                "null"
              ]
            },
            "uid": {
              "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "lastRecordTime": {
          "type": [
            "string",
            "null"
          ],
          "format": "date-time"
        },
        "lastScheduleTime": {
          "description": "Information when was the last time the job was successfully scheduled.",
          "type": [
            "string",
            "null"
          ],
          "format": "date-time"
        },
        "lastSuccessTime": {
          "type": [
            "string",
            "null"
          ],
          "format": "date-time"
        },
        "numRecords": {
          "type": [
            "integer",
            "null"
          ],
          "format": "int64",
          "minimum": 0
        },
        "status": {
          "type": [
            "string",
            "null"
          ],
          "enum": [
            "STARTING",
            "RUNNING",
            "SUCCEEDED",
            "FAILED"
          ]
        }
      },
      "additionalProperties": false
    }
  },
  "x-kubernetes-group-version-kind": [
    {
      "group": "motion.fybrik.io",
      "kind": "BatchTransfer",
      "version": "v1alpha1"
    }
  ],
  "additionalProperties": false,
  "$schema": "http://json-schema.org/schema#"
}